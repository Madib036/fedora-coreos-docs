= Using a remote Ignition config

With Ignition, you are not limited to the configuration provided locally to a system and can retrieve other Ignition configs from a remote source. Those configs will then either replace or be merged into the existing config.

The complete list of supported protocols and related options for remote Ignition files is described in the https://coreos.github.io/ignition/specs/[Ignition specification].

The following examples show how to retrieve an Ignition file from a remote source. They are both set to replace the current configuration with a remote Ignition file.

.Retrieving a remote Ignition file via HTTPS
[source,yaml,subs="attributes"]
----
variant: fcos
version: {butane-latest-stable-spec}
ignition:
  config:
    replace:
      source: https://example.com/sample.ign
----

.Retrieving a remote Ignition file via HTTPS with a custom certificate authority
[source,yaml,subs="attributes"]
----
variant: fcos
version: {butane-latest-stable-spec}
ignition:
  config:
    replace:
      source: https://example.com/sample.ign
  security:
    tls:
      certificate_authorities:
        - source: https://example.com/source1
----

NOTE: The certificate authorities listed here are not automatically added to the host filesystem. They are solely used by Ignition itself when fetching over `https`. If you'd like to also install them on the host filesystem, include them as usual under the `storage.files` array.

In some cases, if you need to merge a local configuration and one or several remote ones, you can use the `merge` rather than `replace` in a Butane config.

.Retrieving a remote Ignition file via HTTPS and merging it with the current config
[source,yaml,subs="attributes"]
----
variant: fcos
version: {butane-latest-stable-spec}
ignition:
  config:
    merge:
      - source: https://example.com/sample.ign
passwd:
  users:
    - name: core
      ssh_authorized_keys:
        - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHn2eh...
----

Retrieving remote Ignition files via plain HTTP is also possible as shown below.

WARNING: Retrieving a remote Ignition config via HTTP exposes the contents of the config to anyone monitoring network traffic. When using HTTP, it is advisable to use the verification option to ensure the contents haven't been tampered with.

.Retrieving a remote Ignition file via HTTP
[source,yaml,subs="attributes"]
----
variant: fcos
version: {butane-latest-stable-spec}
ignition:
  config:
    replace:
      source: http://example.com/sample.ign
      verification:
        hash: sha512-e2bb19fdbc3604f511b13d66f4c675f011a63dd967b97e2fe4f5d50bf6cb224e902182221ba0f9dd87c0bb4abcbd2ab428eb7965aa7f177eb5630e7a1793e2e6
----

If you need to retrieve a remote Ignition file but have no direct access to the remote host, you can specify a proxy for plain HTTP and/or HTTPS. You can also specify hosts that should be excluded from proxying.

.Retrieving a remote Ignition file via a proxy
[source,yaml,subs="attributes"]
----
variant: fcos
version: {butane-latest-stable-spec}
ignition:
  config:
    merge:
      - source: https://example.com/sample.ign
      - source: https://example.org/example.ign
  proxy:
    https_proxy: https://example.net
    no_proxy:
      - example.org
----

'use strict';

const execa = require('execa');
const { mkdirp, writeFileSync, existsSync, readdirSync } = require('fs-extra');
const { join } = require('path');
const { rmSync } = require('fs');

const cli = require.resolve('create-react-app/index.js');

// Increase the timeout for GitHub macOS runner
jest.setTimeout(1000 * 60 * (process.env.RUNNER_OS === 'macOS' ? 10 : 5));

const projectName = 'test-app';
const genPath = join(__dirname, projectName);

const generatedFiles = [
  '.gitignore',
  'README.md',
  'node_modules',
  'package.json',
  'public',
  'src',
  'package-lock.json',
];

const removeGenPath = () => {
  rmSync(genPath, {
    recursive: true,
    force: true,
  });
};

beforeEach(removeGenPath);
afterAll(async () => {
  removeGenPath();
  // Defer jest result output waiting for stdout to flush
  await new Promise(resolve => setTimeout(resolve, 100));
});

const run = async (args, options) => {
  process.stdout.write(
    `::group::Test "${
      expect.getState().currentTestName
    }" - "create-react-app ${args.join(' ')}" output:\n`
  );
  const result = execa('node', [cli].concat(args), options);
  result.stdout.on('data', chunk =>
    process.stdout.write(chunk.toString('utf8'))
  );
  const childProcessResult = await result;
  process.stdout.write(`ExitCode: ${childProcessResult.exitCode}\n`);
  process.stdout.write('::endgroup::\n');
  const files = existsSync(genPath)
    ? readdirSync(genPath).filter(f => existsSync(join(genPath, f)))
    : null;
  return {
    ...childProcessResult,
    files,
  };
};

const expectAllFiles = (arr1, arr2) =>
  expect([...arr1].sort()).toEqual([...arr2].sort());

describe('create-react-app', () => {
  it('check yarn installation', async () => {
    const { exitCode } = await execa('yarn', ['--version']);

    // Assert for exit code
    expect(exitCode).toBe(0);
  });

  it('asks to supply an argument if none supplied', async () => {
    const { exitCode, stderr, files } = await run([], { reject: false });

    // Assertions
    expect(exitCode).toBe(1);
    expect(stderr).toContain('Please specify the project directory');
    expect(files).toBe(null);
  });

  it('creates a project on supplying a name as the argument', async () => {
    const { exitCode, files } = await run([projectName], { cwd: __dirname });

    // Assert for exit code
    expect(exitCode).toBe(0);

    // Assert for the generated files
    expectAllFiles(files, generatedFiles);
  });

  it('warns about conflicting files in path', async () => {
    // Create the temporary directory
    await mkdirp(genPath);

    // Create a package.json file
    const pkgJson = join(genPath, 'package.json');
    writeFileSync(pkgJson, '{ "foo": "bar" }');

    const { exitCode, stdout, files } = await run([projectName], {
      cwd: __dirname,
      reject: false,
    });

    // Assert for exit code
    expect(exitCode).toBe(1);

    // Assert for the expected message
    expect(stdout).toContain(
      `The directory ${projectName} contains files that could conflict`
    );

    // Existing file is still there
    expectAllFiles(files, ['package.json']);
  });

  it('creates a project in the current directory', async () => {
    // Create temporary directory
    await mkdirp(genPath);

    // Create a project in the current directory
    const { exitCode, files } = await run(['.'], { cwd: genPath });

    // Assert for exit code
    expect(exitCode).toBe(0);

    // Assert for the generated files
    expectAllFiles(files, generatedFiles);
  });

  it('uses yarn as the package manager', async () => {
    const { exitCode, files } = await run([projectName], {
      cwd: __dirname,
      env: { npm_config_user_agent: 'yarn' },
    });

    // Assert for exit code
    expect(exitCode).toBe(0);

    // Assert for the generated files
    const generatedFilesWithYarn = generatedFiles.map(file =>
      file === 'package-lock.json' ? 'yarn.lock' : file
    );

    expectAllFiles(files, generatedFilesWithYarn);
  });

  it('creates a project based on the typescript template', async () => {
    const { exitCode, files } = await run(
      [projectName, '--template', 'typescript'],
      {
        cwd: __dirname,
      }
    );

    // Assert for exit code
    expect(exitCode).toBe(0);

    // Assert for the generated files
    expectAllFiles(files, [...generatedFiles, 'tsconfig.json']);
  });
});
